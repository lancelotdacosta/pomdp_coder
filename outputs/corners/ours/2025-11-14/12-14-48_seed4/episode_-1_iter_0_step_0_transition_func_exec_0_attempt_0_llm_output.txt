```python
def transition_func(state, action):
    """
    Args:
        state (MinigridState): the state of the environment 
        action (int): action to be taken in state `state`
    Returns:
        new_state (MinigridState): the new state of the environment
    """

    def move_forward(state):
        # Calculate the new position based on the agent's direction
        new_pos = np.array(state.agent_pos) + DIR_TO_VEC[state.agent_dir]
        x, y = new_pos

        # Check if the new position is within the grid and not a wall
        if 0 <= x < state.width and 0 <= y < state.height and state.grid[x, y] != ObjectTypes.wall:
            return MinigridState(
                grid=state.grid.copy(),
                agent_pos=(x, y),
                agent_dir=state.agent_dir,
                carrying=state.carrying
            )
        else:
            return state

    def turn_left(state):
        new_dir = (state.agent_dir - 1) % 4
        return MinigridState(
            grid=state.grid.copy(),
            agent_pos=state.agent_pos,
            agent_dir=new_dir,
            carrying=state.carrying
        )

    def turn_right(state):
        new_dir = (state.agent_dir + 1) % 4
        return MinigridState(
            grid=state.grid.copy(),
            agent_pos=state.agent_pos,
            agent_dir=new_dir,
            carrying=state.carrying
        )

    def pickup(state):
        # Check if the agent is on an object that can be picked up
        x, y = state.agent_pos
        object_type = state.grid[x, y]

        if object_type in [ObjectTypes.key, ObjectTypes.ball, ObjectTypes.box]:
            new_grid = state.grid.copy()
            new_grid[x, y] = ObjectTypes.empty
            return MinigridState(
                grid=new_grid,
                agent_pos=state.agent_pos,
                agent_dir=state.agent_dir,
                carrying=object_type
            )
        else:
            return state

    def drop(state):
        # Check if the agent is carrying an object and the cell in front is empty
        x, y = state.agent_pos
        if state.carrying is not None and state.grid[x, y] == ObjectTypes.empty:
            new_grid = state.grid.copy()
            new_grid[x, y] = state.carrying
            return MinigridState(
                grid=new_grid,
                agent_pos=state.agent_pos,
                agent_dir=state.agent_dir,
                carrying=None
            )
        else:
            return state

    def toggle(state):
        # Implement toggling logic if needed (e.g., opening/closing doors)
        return state

    def done(state):
        # Implement task completion logic if needed
        return state

    # Dispatch the action to the appropriate function
    if action == Actions.left:
        return turn_left(state)
    elif action == Actions.right:
        return turn_right(state)
    elif action == Actions.forward:
        return move_forward(state)
    elif action == Actions.pickup:
        return pickup(state)
    elif action == Actions.drop:
        return drop(state)
    elif action == Actions.toggle:
        return toggle(state)
    elif action == Actions.done:
        return done(state)
    else:
        raise ValueError(f"Unknown action: {action}")
```

This implementation models the transition function for a Minigrid environment, handling actions such as turning left, turning right, moving forward, picking up objects, dropping objects, toggling objects, and marking the task as done. The function dispatches to the appropriate helper function based on the action provided, ensuring that the new state is computed correctly according to the rules of the environment.