```python
def observation_func(state, action, empty_obs):
    """
    Args:
        state (MinigridState): the state of the environment
        action (int): the previous action that was taken
        empty_obs (MinigridObservation): an empty observation that needs to be filled and returned
    Returns:
        obs (MinigridObservation): observation of the agent
    """

    def rotate_grid(grid, rotations):
        """Rotate the grid by 90 degrees clockwise for `rotations` times."""
        for _ in range(rotations):
            grid = np.rot90(grid, k=1)
        return grid

    def get_partial_view(grid, agent_pos, agent_dir, view_size):
        """Get the partial view of the grid from the agent's perspective."""
        topX, topY = agent_pos
        if agent_dir == Direction.facing_right:
            topY -= view_size // 2
        elif agent_dir == Direction.facing_down:
            topX -= view_size // 2
        elif agent_dir == Direction.facing_left:
            topX -= view_size - 1
            topY -= view_size // 2
        elif agent_dir == Direction.facing_up:
            topX -= view_size // 2
            topY -= view_size - 1

        fov = np.full((view_size, view_size), ObjectTypes.wall, dtype=grid.dtype)

        # Compute the overlapping region in the grid.
        gx0 = max(topX, 0)
        gy0 = max(topY, 0)
        gx1 = min(topX + view_size, grid.shape[0])
        gy1 = min(topY + view_size, grid.shape[1])

        # Determine where the overlapping region goes in the padded array.
        px0 = max(0, -topX)
        py0 = max(0, -topY)

        # Copy the overlapping slice.
        fov[px0 : px0 + (gx1 - gx0), py0 : py0 + (gy1 - gy0)] = grid[gx0:gx1, gy0:gy1]

        return fov

    def update_agent_position(grid, agent_pos):
        """Update the grid to mark the agent's position."""
        agent_pos_grid = (grid.shape[0] // 2, grid.shape[1] - 1)
        grid[agent_pos_grid] = ObjectTypes.agent
        return grid

    # Get the partial view of the grid from the agent's perspective.
    view_size = 3
    fov = get_partial_view(state.grid, state.agent_pos, state.agent_dir, view_size)

    # Rotate the field of view based on the agent's direction.
    fov = rotate_grid(fov, state.agent_dir)

    # Update the agent's position in the field of view.
    fov = update_agent_position(fov, state.agent_pos)

    # Create the observation object.
    empty_obs.image = fov
    empty_obs.agent_pos = state.agent_pos
    empty_obs.agent_dir = state.agent_dir
    empty_obs.carrying = state.carrying

    return empty_obs
```