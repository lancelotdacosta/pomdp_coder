Certainly! Below is the implementation of the `transition_func` function that models the distribution of next states conditioned on actions and previous states. The function follows the logic provided by the environment samples.

The function handles the following actions:
- Turn left (0): Rotates the agent's direction counterclockwise.
- Turn right (1): Rotates the agent's direction clockwise.
- Move forward (2): Moves the agent one step forward in the direction it is facing, if possible.
- Pick up (3): Picks up an object if the agent is standing next to it.
- Drop (4): Drops the object the agent is carrying, if any.
- Toggle (5): Toggles/activates an object (not implemented for this example).
- Done (6): Indicates the task is completed (no change in state).

Here is the implementation:

```python
from __future__ import annotations

from dataclasses import dataclass
from enum import IntEnum
from typing import Any, List, Optional, Tuple

import numpy as np
from numpy.typing import NDArray

AGENT_DIR_TO_STR = {0: ">", 1: "V", 2: "<", 3: "^"}
DIR_TO_VEC = [
    # Pointing right (positive X)
    np.array((1, 0)),
    # Down (positive Y)
    np.array((0, 1)),
    # Pointing left (negative X)
    np.array((-1, 0)),
    # Up (negative Y)
    np.array((0, -1)),
]

SEE_THROUGH_WALLS = True


class ObjectTypes(IntEnum):
    unseen = 0
    empty = 1
    wall = 2
    open_door = 4
    closed_door = 5
    locked_door = 6
    key = 7
    ball = 8
    box = 9
    goal = 10
    lava = 11
    agent = 12


class Direction(IntEnum):
    facing_right = 0
    facing_down = 1
    facing_left = 2
    facing_up = 3


class Actions(IntEnum):
    left = 0  # Turn left
    right = 1  # Turn right
    forward = 2  # Move forward
    pickup = 3  # Pick up an object
    drop = 4  # Drop an object
    toggle = 5  # Toggle/activate an object
    done = 6  # Done completing the task


@dataclass
class MinigridObservation(Observation):
    image: NDArray[np.int8]
    agent_pos: Tuple[int, int]
    agent_dir: int
    carrying: Optional[int] = None


@dataclass
class MinigridState(State):
    grid: NDArray[np.int8]
    agent_pos: Tuple[int, int]
    agent_dir: int
    carrying: Optional[int]

    @property
    def front_pos(self) -> Tuple[int, int]:
        return (
            np.array(self.agent_pos) + np.array(DIR_TO_VEC[self.agent_dir])
        ).tolist()

    @property
    def width(self) -> int:
        return self.grid.shape[0]

    @property
    def height(self) -> int:
        return self.grid.shape[1]

    def get_type_indices(self, type: int) -> List[Tuple[int, int]]:
        idxs = np.where(self.grid == type)
        return list(zip(idxs[0], idxs[1]))

    def get_field_of_view(self, view_size: int) -> NDArray[np.int8]:
        topX, topY = 0, 0
        if self.agent_dir == 0:
            topX = self.agent_pos[0]
            topY = self.agent_pos[1] - view_size // 2
        elif self.agent_dir == 1:
            topX = self.agent_pos[0] - view_size // 2
            topY = self.agent_pos[1]
        elif self.agent_dir == 2:
            topX = self.agent_pos[0] - view_size + 1
            topY = self.agent_pos[1] - view_size // 2
        elif self.agent_dir == 3:
            topX = self.agent_pos[0] - view_size // 2
            topY = self.agent_pos[1] - view_size + 1

        fov = np.full((view_size, view_size), ObjectTypes.wall, dtype=self.grid.dtype)
        gx0 = max(topX, 0)
        gy0 = max(topY, 0)
        gx1 = min(topX + view_size, self.grid.shape[0])
        gy1 = min(topY + view_size, self.grid.shape[1])

        px0 = max(0, -topX)
        py0 = max(0, -topY)
        fov[px0 : px0 + (gx1 - gx0), py0 : py0 + (gy1 - gy0)] = self.grid[gx0:gx1, gy0:gy1]

        for _ in range(self.agent_dir + 1):
            fov = np.rot90(fov.T, k=1).T

        agent_pos = (self.grid.shape[0] // 2, self.grid.shape[1] - 1)
        self.grid[agent_pos] = ObjectTypes.agent

        return fov


def transition_func(state, action):
    if action == Actions.left:
        # Turn left
        new_agent_dir = (state.agent_dir - 1) % 4
        new_state = MinigridState(
            grid=state.grid.copy(),
            agent_pos=state.agent_pos,
            agent_dir=new_agent_dir,
            carrying=state.carrying
        )
    elif action == Actions.right:
        # Turn right
        new_agent_dir = (state.agent_dir + 1) % 4
        new_state = MinigridState(
            grid=state.grid.copy(),
            agent_pos=state.agent_pos,
            agent_dir=new_agent_dir,
            carrying=state.carrying
        )
    elif action == Actions.forward:
        # Move forward
        front_pos = np.array(state.agent_pos) + DIR_TO_VEC[state.agent_dir]
        if 0 <= front_pos[0] < state.width and 0 <= front_pos[1] < state.height:
            if state.grid[tuple(front_pos)] == ObjectTypes.empty:
                new_agent_pos = tuple(front_pos)
                new_state = MinigridState(
                    grid=state.grid.copy(),
                    agent_pos=new_agent_pos,
                    agent_dir=state.agent_dir,
                    carrying=state.carrying
                )
            else:
                new_state = state
        else:
            new_state = state
    elif action == Actions.pickup:
        # Pick up an object
        front_pos = np.array(state.agent_pos) + DIR_TO_VEC[state.agent_dir]
        if 0 <= front_pos[0] < state.width and 0 <= front_pos[1] < state.height:
            if state.grid[tuple(front_pos)] in [ObjectTypes.key, ObjectTypes.ball, ObjectTypes.box]:
                new_grid = state.grid.copy()
                new_grid[tuple(front_pos)] = ObjectTypes.empty
                new_state = MinigridState(
                    grid=new_grid,
                    agent_pos=state.agent_pos,
                    agent_dir=state.agent_dir,
                    carrying=state.grid[tuple(front_pos)]
                )
            else:
                new_state = state
        else:
            new_state = state
    elif action == Actions.drop:
        # Drop an object
        if state.carrying is not None:
            front_pos = np.array(state.agent_pos) + DIR_TO_VEC[state.agent_dir]
            if 0 <= front_pos[0] < state.width and 0 <= front_pos[1] < state.height:
                if state.grid[tuple(front_pos)] == ObjectTypes.empty:
                    new_grid = state.grid.copy()
                    new_grid[tuple(front_pos)] = state.carrying
                    new_state = MinigridState(
                        grid=new_grid,
                        agent_pos=state.agent_pos,
                        agent_dir=state.agent_dir,
                        carrying=None
                    )
                else:
                    new_state = state
            else:
                new_state = state
        else:
            new_state = state
    elif action == Actions.toggle:
        # Toggle/activate an object (not implemented for this example)
        new_state = state
    elif action == Actions.done:
        # Indicate the task is completed (no change in state)
        new_state = state
    return new_state
```

This function should correctly model the transition of states based on the given actions and initial states. It handles turning, moving forward, picking up, and dropping objects, while ensuring that the agent does not move through walls or pick up/drop objects in invalid positions.