To correctly model the distribution of observations conditioned on a state in the MiniGrid environment, we need to ensure that the field of view (FOV) is correctly aligned with the agent's perspective and that the agent's position and direction are accurately reflected in the observation. The discrepancies in the generated samples indicate issues with the alignment and rotation of the FOV.

Here's an improved version of the `observation_func` function:

```python
import numpy as np

def observation_func(state: MinigridState, action: int, empty_obs: MinigridObservation) -> MinigridObservation:
    """
    Args:
        state (MinigridState): the state of the environment
        action (int): the previous action that was taken
        empty_obs (MinigridObservation): an empty observation that needs to be filled and returned
    Returns:
        obs (MinigridObservation): observation of the agent
    """
    view_size = 3  # The size of the agent's field of view

    # Get the extents of the square set of tiles visible to the agent
    if state.agent_dir == Direction.facing_right:
        topX = state.agent_pos[0]
        topY = state.agent_pos[1] - view_size // 2
    elif state.agent_dir == Direction.facing_down:
        topX = state.agent_pos[0] - view_size // 2
        topY = state.agent_pos[1]
    elif state.agent_dir == Direction.facing_left:
        topX = state.agent_pos[0] - view_size + 1
        topY = state.agent_pos[1] - view_size // 2
    elif state.agent_dir == Direction.facing_up:
        topX = state.agent_pos[0] - view_size // 2
        topY = state.agent_pos[1] - view_size + 1
    else:
        assert False, "invalid agent direction"

    fov = np.full((view_size, view_size), ObjectTypes.wall, dtype=state.grid.dtype)

    # Compute the overlapping region in the grid.
    gx0 = max(topX, 0)
    gy0 = max(topY, 0)
    gx1 = min(topX + view_size, state.grid.shape[0])
    gy1 = min(topY + view_size, state.grid.shape[1])

    # Determine where the overlapping region goes in the padded array.
    px0 = max(0, -topX)
    py0 = max(0, -topY)

    # Copy the overlapping slice.
    fov[px0 : px0 + (gx1 - gx0), py0 : py0 + (gy1 - gy0)] = state.grid[gx0:gx1, gy0:gy1]

    # Rotate the field of view to align with the agent's perspective
    for _ in range(state.agent_dir):
        fov = np.rot90(fov, k=1)

    # Place the agent in the correct position in the FOV
    agent_pos_in_fov = (view_size // 2, view_size // 2)
    fov[agent_pos_in_fov] = ObjectTypes.agent

    # Create the observation object
    obs = MinigridObservation(
        image=fov,
        agent_pos=state.agent_pos,
        agent_dir=state.agent_dir,
        carrying=state.carrying
    )

    return obs
```

### Explanation of Changes:

1. **Field of View Calculation**:
   - The calculation of `topX` and `topY` is based on the agent's direction to correctly determine the visible area.
   - The overlapping region in the grid is computed and copied into the `fov` array.

2. **Rotation**:
   - The field of view is rotated `state.agent_dir` times to align with the agent's perspective.

3. **Agent Position in FOV**:
   - The agent is placed at the center of the field of view, which is `(view_size // 2, view_size // 2)`.

This improved function should better model the true distribution of observations conditioned on the state.