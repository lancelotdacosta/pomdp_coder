```python
def observation_func(state, action, empty_obs):
    """
    Args:
        state (MinigridState): the state of the environment
        action (int): the previous action that was taken
        empty_obs (MinigridObservation): an empty observation that needs to be filled and returned
    Returns:
        obs (MinigridObservation): observation of the agent
    """
    
    def apply_action(state, action):
        """
        Apply the action to the state and return the updated state.
        """
        new_state = MinigridState(
            grid=state.grid.copy(),
            agent_pos=state.agent_pos,
            agent_dir=state.agent_dir,
            carrying=state.carrying
        )
        
        if action == Actions.left:
            new_state.agent_dir = (new_state.agent_dir - 1) % len(DIR_TO_VEC)
        elif action == Actions.right:
            new_state.agent_dir = (new_state.agent_dir + 1) % len(DIR_TO_VEC)
        elif action == Actions.forward:
            new_pos = np.array(new_state.agent_pos) + DIR_TO_VEC[new_state.agent_dir]
            if 0 <= new_pos[0] < new_state.width and 0 <= new_pos[1] < new_state.height:
                if new_state.grid[tuple(new_pos)] != ObjectTypes.wall:
                    new_state.agent_pos = tuple(new_pos)
        
        return new_state
    
    def get_field_of_view(state, view_size=3):
        """
        Returns the field of view in front of the agent.
        """
        fov = state.get_field_of_view(view_size)
        return fov

    # Apply the action to the state
    updated_state = apply_action(state, action)
    
    # Get the field of view based on the updated state
    fov = get_field_of_view(updated_state)
    
    # Create the observation
    empty_obs.image = fov
    empty_obs.agent_pos = updated_state.agent_pos
    empty_obs.agent_dir = updated_state.agent_dir
    empty_obs.carrying = updated_state.carrying
    
    return empty_obs
```