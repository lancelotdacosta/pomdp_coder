Certainly! Here's the implementation of the `transition_func` function, which models the distribution of next states conditioned on actions and previous states.

### Explanation of the Transition Logic:
1. **Movement Actions (0-3)**: The agent moves in one of the four cardinal directions (north, south, east, west). The new position is calculated by adding the corresponding movement vector to the current position. If the new position is within the grid boundaries, the agent moves to that position. Otherwise, it stays in its current position.
2. **Sample Action (4)**: If the agent is at a rock location, sampling the rock changes its state from good to bad. If the agent is not at a rock location, the action has no effect.
3. **Exit Action (5)**: This action does not change the state and is typically used to terminate the episode.
4. **Check Actions (6-7)**: These actions do not change the state but provide noisy observations of the rock's quality. The transition function only handles state transitions, so these actions do not affect the state.

### Implementation of `transition_func`:

```python
def transition_func(state: RockSampleState, action: int) -> RockSampleState:
    """
    Args:
        state (RockSampleState): the state of the environment 
        action (int): action to be taken in state `state`
    Returns:
        new_state (RockSampleState): the new state of the environment
    """
    x, y = state.x, state.y
    rocks = list(state.rocks)
    
    if action in [RockSampleActions.MOVE_NORTH, RockSampleActions.MOVE_SOUTH,
                  RockSampleActions.MOVE_EAST, RockSampleActions.MOVE_WEST]:
        # Calculate new position based on action
        if action == RockSampleActions.MOVE_NORTH:
            y = max(0, y - 1)
        elif action == RockSampleActions.MOVE_SOUTH:
            y = min(GRID_SIZE - 1, y + 1)
        elif action == RockSampleActions.MOVE_EAST:
            x = min(GRID_SIZE - 1, x + 1)
        elif action == RockSampleActions.MOVE_WEST:
            x = max(0, x - 1)
    
    elif action == RockSampleActions.SAMPLE:
        rock_idx = state.at_rock()
        if rock_idx is not None:
            rocks[rock_idx] = False  # Sample the rock, changing its state to bad
    
    elif action == RockSampleActions.EXIT:
        # Exit action does not change the state
        pass
    
    # Create new state with updated position and rock states
    new_state = RockSampleState(x, y, tuple(rocks))
    return new_state
```

This implementation ensures that the agent's movement is constrained within the grid boundaries, and the sampling action changes the state of the rock if the agent is at a rock location. The exit action does not alter the state, and check actions are not handled in this transition function as they do not affect the state.