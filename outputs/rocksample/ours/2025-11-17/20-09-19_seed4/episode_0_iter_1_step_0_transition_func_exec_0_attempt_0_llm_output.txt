```python
def transition_func(state, action):
    """
    Args:
        state (RockSampleState): the state of the environment 
        action (int): action to be taken in state `state`
    Returns:
        new_state (RockSampleState): the new state of the environment
    """
    new_state = copy.deepcopy(state)
    
    if action == RockSampleActions.MOVE_NORTH:
        new_state.y = max(0, new_state.y - 1)
    elif action == RockSampleActions.MOVE_SOUTH:
        new_state.y = min(GRID_SIZE - 1, new_state.y + 1)
    elif action == RockSampleActions.MOVE_EAST:
        new_state.x = min(GRID_SIZE - 1, new_state.x + 1)
    elif action == RockSampleActions.MOVE_WEST:
        new_state.x = max(0, new_state.x - 1)
    elif action == RockSampleActions.SAMPLE:
        rock_idx = new_state.at_rock()
        if rock_idx is not None:
            new_state.rocks = tuple(r if i != rock_idx else False for i, r in enumerate(new_state.rocks))
    elif action == RockSampleActions.EXIT:
        pass  # No change in state
    elif action in CHECK_ACTIONS:
        rock_idx = new_state.at_rock()
        if rock_idx is not None and action == RockSampleActions.CHECK_ROCK_0 + rock_idx:
            # No change in state, just an observation
            pass

    return new_state
```

### Explanation of the Transition Function

The transition function models the next state based on the current state and the action taken. Here's a breakdown of how each action affects the state:

1. **Move Actions**:
   - `MOVE_NORTH`: Decrements the y-coordinate by 1, ensuring it doesn't go below 0.
   - `MOVE_SOUTH`: Increments the y-coordinate by 1, ensuring it doesn't exceed the grid size.
   - `MOVE_EAST`: Increments the x-coordinate by 1, ensuring it doesn't exceed the grid size.
   - `MOVE_WEST`: Decrements the x-coordinate by 1, ensuring it doesn't go below 0.

2. **Sample Action**:
   - If the agent is at a rock position, the rock's status is set to `False` (bad), indicating it has been sampled.

3. **Exit Action**:
   - No change in the state. This action is typically used to end the episode or perform some other terminal action.

4. **Check Rock Actions**:
   - These actions are used to check the quality of a rock (good or bad). However, they do not change the state; they only provide an observation.

The function ensures that the agent's position remains within the grid boundaries and updates the rock states accordingly when the agent performs the sample action. The function also handles the check rock actions by verifying if the agent is at a rock and if the action corresponds to checking that rock.