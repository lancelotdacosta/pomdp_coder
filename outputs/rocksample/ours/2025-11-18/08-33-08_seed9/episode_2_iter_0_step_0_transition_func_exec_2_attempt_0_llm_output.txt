The error you're encountering is due to the `transition_func` returning a tuple when the calling code expects a `RockSampleState` object. To resolve this, we need to ensure that the `transition_func` always returns a `RockSampleState` object, and handle the observation separately if needed.

Here's the corrected `transition_func` that always returns a `RockSampleState` object and handles the observation separately:

```python
def transition_func(state, action):
    """
    Args:
        state (RockSampleState): the state of the environment 
        action (int): action to be taken in state `state`
    Returns:
        new_state (RockSampleState): the new state of the environment
        observation (RockSampleObservation): the observation after the action
    """
    x, y = state.x, state.y
    rocks = list(state.rocks)
    observation = RockSampleObservation(x, y, None, None)  # Default observation

    if action == RockSampleActions.MOVE_NORTH:
        y = max(y - 1, 1)
    elif action == RockSampleActions.MOVE_SOUTH:
        y = min(y + 1, GRID_SIZE)
    elif action == RockSampleActions.MOVE_EAST:
        x = min(x + 1, GRID_SIZE)
    elif action == RockSampleActions.MOVE_WEST:
        x = max(x - 1, 1)
    elif action == RockSampleActions.SAMPLE:
        rock_idx = state.at_rock()
        if rock_idx is not None:
            rocks[rock_idx] = False  # Sample the rock and mark it as BAD
    elif action == RockSampleActions.EXIT:
        pass  # No change in state
    elif action in CHECK_ACTIONS:
        rock_idx = action - RockSampleActions.CHECK_ROCK_0
        if (x, y) == ROCK_POSITIONS[rock_idx]:
            is_good = rocks[rock_idx]
            if random.random() < 0.9:  # 90% chance of correct reading
                is_good = not is_good
            observation = RockSampleObservation(x, y, rock_idx, is_good)
        else:
            observation = RockSampleObservation(x, y, None, None)

    new_state = RockSampleState(x, y, tuple(rocks))
    return new_state, observation
```

### Explanation

1. **Move Actions (NORTH, SOUTH, EAST, WEST)**:
   - The agent's position changes based on the action.
   - The agent cannot move outside the grid boundaries (1 to `GRID_SIZE` for both x and y).
   - The rocks' states remain unchanged.

2. **Sample Action**:
   - If the agent is at a rock's position, the rock is sampled and marked as BAD (`False`).
   - If the agent is not at a rock's position, no change occurs in the state.

3. **Exit Action**:
   - No change in the state.

4. **Check Rock Actions**:
   - If the agent is at the rock's position, a noisy observation is generated.
   - The observation has a 90% chance of being correct.
   - If the agent is not at the rock's position, the observation is `None`.
   - The rocks' states remain unchanged.

### Handling Observations

The function now always returns a tuple containing the new state and the observation. This should resolve the `AttributeError` you encountered. The calling code will need to handle the tuple return type correctly.

Here's how you might use it:

```python
# Example usage
state = RockSampleState(x=1, y=1, rocks=[True, False])
action = RockSampleActions.MOVE_NORTH
new_state, observation = transition_func(state, action)
print(new_state)  # RockSampleState(x=1, y=1, rocks=[True, False])
print(observation)  # RockSampleObservation(x=1, y=1, rock_idx=None, is_good=None)
```

This ensures that the `transition_func` always returns a `RockSampleState` object and an observation, which should be correctly handled by the calling code.